{% extends "base.html" %}
{% block content %}
<div class="bg-white p-6 rounded shadow">
    <div class="mb-6">
        <h2 class="text-2xl font-bold">Print Request Details</h2>
        <p class="text-gray-600">Submitted by: {{ print_request.user.username }}</p>
        <p class="text-gray-600">Status: {{ print_request.status }}</p>
        <p class="text-gray-600">Submitted: {{ print_request.timestamp.strftime('%Y-%m-%d %H:%M') }}</p>
    </div>

    <div class="mb-6">
        <h3 class="text-xl font-bold mb-2">Print Information</h3>
        <p>Estimated Time: {{ print_request.estimated_time }} minutes</p>
        <p>Material Type: {{ print_request.material_type }}</p>
        <p>Material Amount: {{ print_request.material_amount }}g</p>
        <p>Layer Height: {{ print_request.layer_height }}mm</p>
        {% if print_request.notes %}
        <p>Notes: {{ print_request.notes }}</p>
        {% endif %}
    </div>

    <div class="mb-6">
        <h3 class="text-xl font-bold mb-2">Actions</h3>
        <div class="space-x-4">
            <a href="{{ url_for('download_gcode', request_id=print_request.id) }}" 
               class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                Download GCode
            </a>
            {% if current_user.is_admin and print_request.status == 'pending' %}
            <a href="{{ url_for('approve_print', request_id=print_request.id) }}"
               class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                Approve
            </a>
            <a href="{{ url_for('deny_print', request_id=print_request.id) }}"
               class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                Deny
            </a>
            {% endif %}
        </div>
    </div>

    <div class="mb-6">
        <h3 class="text-xl font-bold mb-2">GCode Viewer</h3>
        <div id="gcode-viewer" class="w-full h-[600px] border rounded"></div>
    </div>

    <!-- GCode preview as text -->
    <div class="mb-6">
        <h3 class="text-xl font-bold mb-2">GCode Preview</h3>
        <pre class="bg-gray-100 p-4 rounded overflow-x-auto max-h-[400px]">{{ gcode_preview }}</pre>
    </div>
</div>

<!-- Include Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Include OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
    #gcode-viewer {
        position: relative;
        width: 100%;
        height: 600px;
        border: 1px solid #ccc;
        border-radius: 4px;
        overflow: hidden;
    }
</style>

<script>
class GCodeViewer {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setClearColor(0xf0f0f0);
        this.container.appendChild(this.renderer.domElement);

        // Add OrbitControls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;

        // Add grid
        const size = 200;
        const divisions = 20;
        const gridHelper = new THREE.GridHelper(size, divisions);
        this.scene.add(gridHelper);

        // Add axes helper
        const axesHelper = new THREE.AxesHelper(50);
        this.scene.add(axesHelper);

        // Set camera position
        this.camera.position.set(100, 100, 100);
        this.camera.lookAt(0, 0, 0);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);

        // Add scale indicators
        this.addScaleIndicators();

        this.animate();
    }

    addScaleIndicators() {
        // Add scale text
        const createScaleLabel = (position, text) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 100;
            canvas.height = 32;
            context.font = '24px Arial';
            context.fillStyle = 'black';
            context.fillText(text, 0, 24);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(10, 5, 1);
            return sprite;
        };

        // Add scale labels every 50mm
        for (let i = 0; i <= 200; i += 50) {
            this.scene.add(createScaleLabel(new THREE.Vector3(i, 0, -5), `${i}mm`));
            this.scene.add(createScaleLabel(new THREE.Vector3(-5, 0, i), `${i}mm`));
        }
    }

    loadGCode(gcode) {
        const lines = gcode.split('\n');
        const points = [];
        let currentPosition = new THREE.Vector3(0, 0, 0);
        let isExtrusion = false;
        let minPos = new THREE.Vector3(Infinity, Infinity, Infinity);
        let maxPos = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

        lines.forEach(line => {
            if (line.startsWith(';')) return; // Skip comments

            const parts = line.split(' ');
            if (line.startsWith('G1') || line.startsWith('G0')) {
                let newPosition = currentPosition.clone();
                isExtrusion = false;

                parts.forEach(part => {
                    if (part.startsWith('X')) newPosition.x = parseFloat(part.substring(1));
                    if (part.startsWith('Y')) newPosition.y = parseFloat(part.substring(1));
                    if (part.startsWith('Z')) newPosition.z = parseFloat(part.substring(1));
                    if (part.startsWith('E') && parseFloat(part.substring(1)) > 0) isExtrusion = true;
                });

                // Update bounds
                minPos.min(newPosition);
                maxPos.max(newPosition);

                if (isExtrusion) {
                    points.push(currentPosition.clone());
                    points.push(newPosition.clone());
                }
                currentPosition = newPosition;
            }
        });

        // Create the 3D visualization
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ 
            color: 0x00ff00,
            linewidth: 2
        });
        const model = new THREE.LineSegments(geometry, material);
        this.scene.add(model);

        // Center and scale the model
        const modelSize = maxPos.clone().sub(minPos);
        const center = minPos.clone().add(modelSize.multiplyScalar(0.5));
        model.position.sub(center);

        // Add bounding box
        const bbox = new THREE.Box3().setFromPoints(points);
        const bboxHelper = new THREE.Box3Helper(bbox, 0xff0000);
        this.scene.add(bboxHelper);

        // Add dimensions display
        const dimensions = bbox.getSize(new THREE.Vector3());
        this.addDimensionsText(`Size: ${dimensions.x.toFixed(1)}mm x ${dimensions.y.toFixed(1)}mm x ${dimensions.z.toFixed(1)}mm`);
    }

    addDimensionsText(text) {
        const dimensionsDiv = document.createElement('div');
        dimensionsDiv.style.position = 'absolute';
        dimensionsDiv.style.top = '10px';
        dimensionsDiv.style.left = '10px';
        dimensionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        dimensionsDiv.style.padding = '5px';
        dimensionsDiv.style.borderRadius = '3px';
        dimensionsDiv.textContent = text;
        this.container.appendChild(dimensionsDiv);
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}


document.addEventListener('DOMContentLoaded', function() {
        const viewer = new GCodeViewer('gcode-viewer');

        // Update the fetch URL to use the correct route
        fetch("{{ url_for('get_gcode', request_id=print_request.id) }}")
            .then(response => response.text())
            .then(gcode => {
                viewer.loadGCode(gcode);
            })
            .catch(error => console.error('Error loading GCode:', error));
    });
</script>
{% endblock %}